/*!
 * @pluginjs/animate-text v0.8.3 (https://pluginjs.com)
 * Copyright 2020 Creation Studio Limited
 * Released under the GPL-3.0 License.
 */
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Component = _interopDefault(require('@pluginjs/component'));
var classes$1 = require('@pluginjs/classes');
var dom = require('@pluginjs/dom');
var events$1 = require('@pluginjs/events');
var is = require('@pluginjs/is');
var decorator = require('@pluginjs/decorator');
var anime = _interopDefault(require('animejs'));
var styled = require('@pluginjs/styled');

var namespace = 'animateText';
var events = {
  READY: 'ready',
  ENABLE: 'enable',
  DISABLE: 'disable',
  DESTROY: 'destroy'
};
var classes = {
  NAMESPACE: "pj-".concat(namespace),
  SWITCH: '{namespace}-switch',
  WORD: '{namespace}-word',
  CHAR: '{namespace}-char',
  SPACE: '{namespace}-space',
  CURSOR: '{namespace}-cursor'
};
var methods = ['enable', 'disable', 'destroy'];
var defaults = {
  mode: 'fadeDown',
  loop: true,
  duration: 1000,
  alt: [] // switch words.  example: ['word1', 'word2']

};
var dependencies = ['anime'];

class Fade {
  constructor(instance) {
    this.instance = instance;
    this.options = this.instance.options;
    this.element = this.instance.element;
    this.initialize();
    this.setupAnime();
  }

  initialize() {
    this.text = dom.text(this.element);
    dom.text('', this.element);
    this.instance.splitWord(this.text);
  }

  setupAnime() {
    if (this.options.loop) {
      anime.timeline({
        targets: this.element,
        loop: true,
        duration: this.options.duration,
        easing: 'linear'
      }).add({
        opacity: [0, 1],
        endDelay: 700
      }).add({
        opacity: [1, 0]
      });
    } else {
      anime({
        targets: this.element,
        opacity: [0, 1],
        duration: this.options.duration,
        loop: false,
        easing: 'linear'
      });
    }
  }

}

class FadeDown extends Fade {
  setupAnime() {
    if (this.options.loop) {
      anime.timeline({
        targets: this.element,
        loop: true,
        duration: this.options.duration,
        easing: 'linear'
      }).add({
        translateY: [-20, 0],
        opacity: [0, 1],
        endDelay: 700
      }).add({
        translateY: [0, 20],
        opacity: [1, 0]
      });
    } else {
      anime({
        targets: this.element,
        translateY: [-20, 0],
        opacity: [0, 1],
        duration: this.options.duration,
        loop: false,
        easing: 'linear'
      });
    }
  }

}

class FadeUp extends Fade {
  setupAnime() {
    if (this.options.loop) {
      anime.timeline({
        targets: this.element,
        loop: true,
        duration: this.options.duration,
        easing: 'linear'
      }).add({
        translateY: [20, 0],
        opacity: [0, 1],
        endDelay: 700
      }).add({
        translateY: [0, -20],
        opacity: [1, 0]
      });
    } else {
      anime({
        targets: this.element,
        translateY: [20, 0],
        opacity: [0, 1],
        duration: this.options.duration,
        loop: false,
        easing: 'linear'
      });
    }
  }

}

class FadeLeft extends Fade {
  setupAnime() {
    if (this.options.loop) {
      anime.timeline({
        targets: this.element,
        loop: true,
        duration: this.options.duration,
        easing: 'linear'
      }).add({
        translateX: [20, 0],
        opacity: [0, 1],
        endDelay: 700
      }).add({
        translateX: [0, -20],
        opacity: [1, 0]
      });
    } else {
      anime({
        targets: this.element,
        translateX: [20, 0],
        opacity: [0, 1],
        duration: this.options.duration,
        loop: false,
        easing: 'linear'
      });
    }
  }

}

class FadeRight extends Fade {
  setupAnime() {
    if (this.options.loop) {
      anime.timeline({
        targets: this.element,
        loop: true,
        duration: this.options.duration,
        easing: 'linear'
      }).add({
        translateX: [-20, 0],
        opacity: [0, 1],
        endDelay: 700
      }).add({
        translateX: [0, 20],
        opacity: [1, 0]
      });
    } else {
      anime({
        targets: this.element,
        translateX: [-20, 0],
        opacity: [0, 1],
        duration: this.options.duration,
        loop: false,
        easing: 'linear'
      });
    }
  }

}

class Zoom {
  constructor(instance) {
    this.instance = instance;
    this.options = this.instance.options;
    this.element = this.instance.element;
    this.initialize();
    this.setupAnime();
  }

  initialize() {
    this.text = dom.text(this.element);
    dom.text('', this.element);
    this.instance.splitWord(this.text);
  }

  setupAnime() {
    if (this.options.loop) {
      anime.timeline({
        targets: this.element,
        loop: true,
        duration: this.options.duration,
        easing: 'easeInOutQuart'
      }).add({
        scale: [0, 1],
        opacity: [0, 1],
        endDelay: 700
      }).add({
        scale: [1, 1.3],
        opacity: [1, 0]
      });
    } else {
      anime({
        targets: this.element,
        scale: [0, 1],
        opacity: [0, 1],
        duration: this.options.duration,
        loop: false,
        easing: 'easeInOutQuart'
      });
    }
  }

}

class Bounce {
  constructor(instance) {
    this.instance = instance;
    this.options = this.instance.options;
    this.element = this.instance.element;
    this.initialize();
    this.setupAnime();
  }

  initialize() {
    this.text = dom.text(this.element);
    dom.text('', this.element);
    this.instance.splitWord(this.text);
  }

  setupAnime() {
    var options = {
      targets: this.element,
      scale: [0.5, 1.2, 0.8, 1.2, 1],
      endDelay: 700 + this.options.duration
    };
    anime.timeline({
      duration: this.options.duration,
      easing: 'easeInOutSine',
      loop: this.options.loop
    }).add(options);
  }

}

class Swing {
  constructor(instance) {
    this.instance = instance;
    this.options = this.instance.options;
    this.element = this.instance.element;
    this.initialize();
    this.setupAnime();
  }

  initialize() {
    this.text = dom.text(this.element);
    dom.text('', this.element);
    this.instance.splitWord(this.text);
    styled.setStyle('transform-origin', 'top center', this.element);
  }

  setupAnime() {
    var options = {
      targets: this.element,
      rotateZ: [-5, 5, -10, 10, 0],
      endDelay: 700 + this.options.duration
    };
    anime.timeline({
      duration: this.options.duration,
      easing: 'easeInOutSine',
      loop: this.options.loop
    }).add(options);
  }

}

class Typewrite {
  constructor(instance) {
    this.instance = instance;
    this.options = this.instance.options;
    this.element = this.instance.element;
    this.initialize();
    this.setupAnime();
  }

  initialize() {
    this.text = dom.text(this.element);
    this.build();
    this.textArr = this.text.split('');
    this.chunk = Array(this.textArr.length + 1).fill(1).map((v, k) => k);
    this.chunkReverse = this.chunk.slice().reverse();
    this.initTextOptions();
  }

  initTextOptions() {
    this.alt = is.isArray(this.options.alt) ? this.options.alt : Array.of(this.options.alt);
    this.totalText = Array.of({
      textArr: this.textArr,
      chunk: this.chunk,
      chunkReverse: this.chunkReverse
    });
    this.alt.forEach(word => {
      var textArr = word.split('');
      var chunk = Array(textArr.length + 1).fill(1).map((v, k) => k);
      var chunkReverse = chunk.slice().reverse();
      this.totalText.push({
        textArr,
        chunk,
        chunkReverse
      });
    });
  }

  build() {
    dom.text('', this.element);
    this.content = document.createElement('span');
    classes$1.addClass(this.instance.classes.WORD, this.content);
    dom.text(this.text, this.content);
    dom.append(this.content, this.element);
    this.cursor = document.createElement('span');
    classes$1.addClass(this.instance.classes.CURSOR, this.cursor);
    dom.text('|', this.cursor);
    dom.append(this.cursor, this.element);
  }

  setupAnime() {
    var count = 0;
    var startTarget = {
      textLen: 0
    };
    var endTarget = {
      textLen: 0
    };
    var startOptions = {
      targets: startTarget,
      textLen: this.totalText[count].chunk.length - 1,
      round: 1,
      duration: this.options.duration,
      easing: 'easeInOutSine',
      update: () => {
        var content = this.totalText[count].textArr.slice(0, this.totalText[count].chunk[startTarget.textLen]).join('');
        dom.text("".concat(content), this.content);
      },
      complete: () => {
        startTarget.textLen = 0;

        if (count === this.totalText.length - 1 && !this.options.loop) {
          this.anime.pause();
        }
      },
      endDelay: 2000
    };
    var endOptions = {
      targets: endTarget,
      textLen: this.totalText[count].chunkReverse.length - 1,
      round: 1,
      duration: this.options.duration / 3,
      easing: 'linear',
      update: () => {
        var content = this.totalText[count].textArr.slice(0, this.totalText[count].chunkReverse[endTarget.textLen]).join('');
        dom.text("".concat(content), this.content);
      },
      complete: () => {
        endTarget.textLen = 0;
        this.anime.pause();

        if (this.options.loop && count === this.totalText.length - 1) {
          count = -1;
        }

        if (count < this.totalText.length - 1) {
          count++;
          animeSetup();
        }
      }
    };
    var that = this;

    function animeSetup() {
      startOptions.textLen = that.totalText[count].chunk.length - 1;
      endOptions.textLen = that.totalText[count].chunkReverse.length - 1;
      that.anime = anime.timeline({}).add(startOptions).add(endOptions);
    }

    animeSetup();
  }

}

class SyncAnimation {
  constructor() {
    if (!window.SyncAnimationGroup) {
      this.animationGroups = [];
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          this.animationGroups.forEach((_ref) => {
            var {
              group,
              onBlur
            } = _ref;
            return group.forEach(onBlur);
          });
        } else {
          this.animationGroups.forEach((_ref2) => {
            var {
              group,
              onFocus
            } = _ref2;
            return group.forEach(onFocus);
          });
        }
      }, false);
      window.SyncAnimationGroup = this;
    }

    return window.SyncAnimationGroup;
  }

  createAnimationGroup(onBlur, onFocus) {
    var animationGroup = {
      group: [],
      onBlur,
      onFocus
    };
    this.animationGroups.push(animationGroup);
    return {
      push() {
        animationGroup.group.push(...arguments);
      }

    };
  }

  static of() {
    return new SyncAnimation();
  }

}

class Switch {
  constructor(instance) {
    this.instance = instance;
    this.options = this.instance.options;
    this.element = this.instance.element;
    this.initialize();
  }

  initialize() {
    this.animationGroup = SyncAnimation.of().createAnimationGroup(anime => anime.pause(), anime => anime.play());

    this.joinSyncAnimationGroup = anime => this.animationGroup.push(anime);

    this.elementHeight = styled.getHeight(this.element);
    this.instance.switchWord();
    this.childrens = Array.from(this.element.children);
    this.widthList = this.getWidthList(this.element);
    this.setPosition();
    styled.setStyle('height', this.elementHeight, this.element);
    this.DOWNTOMID = [this.elementHeight, 0];
    this.MIDTOUP = [0, this.elementHeight * -1];
    this.totalDuration = this.options.duration * this.childrens.length;
  }

  getContainerOptions() {
    return {
      targets: this.element,
      duration: this.totalDuration,
      easing: 'easeOutCirc',
      begin: this.joinSyncAnimationGroup,
      loop: this.options.loop,
      width: this.widthList
    };
  }

  getWidthList(element) {
    var widthArr = Array.from(element.children).map(node => {
      return node.offsetWidth;
    });
    var widthList = [];
    widthList.push({
      value: widthArr[widthArr.length - 1],
      duration: 0
    });
    widthArr.forEach(width => {
      widthList.push({
        value: width,
        duration: this.options.duration
      });
    });
    return widthList;
  }

  setPosition() {
    this.childrens.forEach(el => {
      styled.setStyle({
        opacity: 0,
        position: 'absolute'
      }, el);
    });
  }

}

class SwitchSlider extends Switch {
  constructor(instance) {
    super(instance);
    this.setupAnime();
  }

  getAnimeDefaultOptions(targets) {
    return {
      targets,
      easing: 'easeInSine',
      duration: this.options.duration,
      begin: this.joinSyncAnimationGroup,
      opacity: [{
        value: [0, 1],
        duration: this.options.duration * (1 / 5)
      }, {
        value: 1,
        duration: this.options.duration * (1 / 5)
      }, {
        value: [1, 0],
        duration: this.options.duration * (3 / 5)
      }],
      translateY: [{
        value: this.DOWNTOMID
      }, {
        value: 0
      }, {
        value: this.MIDTOUP
      }]
    };
  }

  setupAnime() {
    anime(this.getContainerOptions());

    if (this.options.loop) {
      anime(Object.assign({}, this.getAnimeDefaultOptions(this.childrens), {
        loop: true,
        delay: (el, i) => i * this.options.duration
      }));
    } else {
      var childrens = this.childrens.map((el, index) => {
        if (index === this.childrens.length - 1) {
          return Object.assign(this.getAnimeDefaultOptions(el), {
            opacity: [[0, 1], 1],
            translateY: [{
              value: this.DOWNTOMID
            }, {
              value: 0
            }],
            loop: false
          });
        }

        return Object.assign(this.getAnimeDefaultOptions(el), {
          loop: false
        });
      });
      childrens.forEach((children, index) => {
        setTimeout(() => anime(children), index * this.options.duration);
      });
    }
  }

}

class SwitchFade extends Switch {
  constructor(instance) {
    super(instance);
    this.setupAnime();
  }

  getAnimeDefaultOptions(targets) {
    return {
      targets,
      easing: 'easeInOutQuart',
      duration: this.options.duration,
      begin: this.joinSyncAnimationGroup,
      opacity: [[0, 1], 1, [1, 0]]
    };
  }

  setupAnime() {
    anime(this.getContainerOptions());

    if (this.options.loop) {
      anime(Object.assign({}, this.getAnimeDefaultOptions(this.childrens), {
        loop: true,
        delay: (el, i) => i * this.options.duration
      }));
    } else {
      var childrens = this.childrens.map((el, index) => {
        if (index === this.childrens.length - 1) {
          return Object.assign(this.getAnimeDefaultOptions(el), {
            opacity: [[0, 1], 1],
            loop: false
          });
        }

        return Object.assign(this.getAnimeDefaultOptions(el), {
          loop: false
        });
      });
      childrens.forEach((children, index) => {
        setTimeout(() => anime(children), index * this.options.duration);
      });
    }
  }

}

class SwitchPush extends Switch {
  constructor(instance) {
    super(instance);
    this.setupAnime();
  }

  getAnimeDefaultOptions(targets) {
    return {
      targets,
      easing: 'easeInBack',
      duration: this.options.duration,
      begin: this.joinSyncAnimationGroup,
      opacity: [{
        value: [0, 1],
        duration: this.options.duration * (1 / 5)
      }, {
        value: 1,
        duration: this.options.duration * (2 / 5)
      }, {
        value: [1, 0],
        duration: this.options.duration * (2 / 5)
      }],
      translateY: [{
        value: this.DOWNTOMID
      }, {
        value: 0
      }, {
        value: this.MIDTOUP
      }]
    };
  }

  setupAnime() {
    anime(this.getContainerOptions());

    if (this.options.loop) {
      anime(Object.assign({}, this.getAnimeDefaultOptions(this.childrens), {
        loop: true,
        delay: (el, i) => i * this.options.duration
      }));
    } else {
      var childrens = this.childrens.map((el, index) => {
        if (index === this.childrens.length - 1) {
          return Object.assign(this.getAnimeDefaultOptions(el), {
            opacity: [{
              value: [0, 1],
              duration: this.options.duration * (1 / 5)
            }, {
              value: 1,
              duration: this.options.duration * (4 / 5)
            }],
            translateY: [{
              value: this.DOWNTOMID
            }, {
              value: 0
            }],
            loop: false
          });
        }

        return Object.assign(this.getAnimeDefaultOptions(el), {
          loop: false
        });
      });
      childrens.forEach((children, index) => {
        setTimeout(() => anime(children), index * this.options.duration);
      });
    }
  }

}

class Char {
  constructor(instance) {
    this.instance = instance;
    this.options = this.instance.options;
    this.element = this.instance.element;
    this.initialize();
  }

  initialize() {
    this.text = dom.text(this.element);
    dom.text('', this.element);
    this.instance.splitWord(this.text, true);
    this.chars = dom.queryAll(".".concat(this.instance.classes.CHAR), this.element);
  }

}

class CharFade extends Char {
  constructor(instance) {
    super(instance);
    this.setupAnime();
  }

  setupAnime() {
    if (this.options.loop) {
      anime.timeline({
        targets: this.chars,
        loop: true,
        duration: this.options.duration,
        easing: 'easeInOutQuad',

        delay(el, i) {
          return 60 * i;
        }

      }).add({
        opacity: [0, 1],
        endDelay: 700
      }).add({
        opacity: [1, 0]
      });
    } else {
      anime({
        targets: this.chars,
        opacity: [0, 1],
        easing: 'easeInOutQuad',
        duration: this.options.duration,
        loop: false,

        delay(el, i) {
          return 60 * i;
        }

      });
    }
  }

}

class CharFadeLeft extends Char {
  constructor(instance) {
    super(instance);
    this.setupAnime();
  }

  setupAnime() {
    if (this.options.loop) {
      anime.timeline({
        targets: this.chars,
        loop: true,
        duration: this.options.duration,

        delay(el, i) {
          return 60 * i;
        }

      }).add({
        translateX: [20, 0],
        easing: 'easeOutQuart',
        opacity: [0, 1],
        endDelay: 700
      }).add({
        translateX: [0, -20],
        easing: 'easeInQuart',
        opacity: [1, 0]
      });
    } else {
      anime({
        targets: this.chars,
        translateX: [20, 0],
        opacity: [0, 1],
        easing: 'easeOutQuart',
        duration: this.options.duration,
        loop: false,

        delay(el, i) {
          return 60 * i;
        }

      });
    }
  }

}

class CharFadeUp extends Char {
  constructor(instance) {
    super(instance);
    this.setupAnime();
  }

  setupAnime() {
    if (this.options.loop) {
      anime.timeline({
        targets: this.chars,
        loop: true,
        duration: this.options.duration,

        delay(el, i) {
          return 60 * i;
        }

      }).add({
        translateY: ['0.7em', 0],
        easing: 'easeOutExpo',
        opacity: [0, 1],
        endDelay: 700
      }).add({
        translateY: [0, '-0.4em'],
        easing: 'easeInExpo',
        opacity: [1, 0]
      });
    } else {
      anime({
        targets: this.chars,
        translateY: ['0.7em', 0],
        opacity: [0, 1],
        easing: 'easeOutExpo',
        duration: this.options.duration,
        loop: false,

        delay(el, i) {
          return 60 * i;
        }

      });
    }
  }

}

class CharFadeDown extends Char {
  constructor(instance) {
    super(instance);
    this.setupAnime();
  }

  setupAnime() {
    if (this.options.loop) {
      anime.timeline({
        targets: this.chars,
        loop: true,
        duration: this.options.duration,

        delay(el, i) {
          return 60 * i;
        }

      }).add({
        translateY: ['-0.7em', 0],
        easing: 'easeOutExpo',
        opacity: [0, 1],
        endDelay: 700
      }).add({
        translateY: [0, '0.4em'],
        easing: 'easeInExpo',
        opacity: [1, 0]
      });
    } else {
      anime({
        targets: this.chars,
        translateY: ['-0.7em', 0],
        opacity: [0, 1],
        easing: 'easeOutExpo',
        duration: this.options.duration,
        loop: false,

        delay(el, i) {
          return 60 * i;
        }

      });
    }
  }

}

class CharPush extends Char {
  constructor(instance) {
    super(instance);
    styled.setStyle({
      overflow: 'hidden',
      'vertical-align': 'bottom'
    }, this.element);
    this.setupAnime();
  }

  setupAnime() {
    if (this.options.loop) {
      anime.timeline({
        targets: this.chars,
        loop: true,
        duration: this.options.duration,

        delay(el, i) {
          return 60 * i;
        }

      }).add({
        translateY: ['0.7em', 0],
        opacity: [0, 1],
        endDelay: 700
      }).add({
        translateY: [0, '-0.5em'],
        easing: 'easeInElastic',
        opacity: [1, 0]
      });
    } else {
      anime({
        targets: this.chars,
        translateY: ['0.7em', 0],
        opacity: [0, 1],
        duration: this.options.duration,
        loop: false,

        delay(el, i) {
          return 60 * i;
        }

      });
    }
  }

}

class CharRotate extends Char {
  constructor(instance) {
    super(instance);
    styled.setStyle({
      overflow: 'hidden',
      'vertical-align': 'bottom'
    }, this.element);
    this.chars.forEach(char => {
      styled.setStyle('transform-origin', '0 100%', char);
    });
    this.setupAnime();
  }

  setupAnime() {
    if (this.options.loop) {
      anime.timeline({
        targets: this.chars,
        loop: true,
        duration: this.options.duration,

        delay(el, i) {
          return 60 * i;
        }

      }).add({
        rotateZ: [180, 0],
        opacity: [0, 1],
        easing: 'easeOutExpo',
        endDelay: 700
      }).add({
        rotateZ: [0, -45],
        opacity: [1, 0],
        easing: 'easeInExpo'
      });
    } else {
      anime({
        targets: this.chars,
        rotateZ: [180, 0],
        opacity: [0, 1],
        easing: 'easeOutExpo',
        duration: this.options.duration,
        loop: false,

        delay(el, i) {
          return 60 * i;
        }

      });
    }
  }

}

class CharBounceOut extends Char {
  constructor(instance) {
    super(instance);
    this.setupAnime();
  }

  setupAnime() {
    if (this.options.loop) {
      anime.timeline({
        targets: this.chars,
        loop: true,
        duration: this.options.duration,

        delay(el, i) {
          return 60 * i;
        }

      }).add({
        scale: [0, 1],
        easing: 'easeOutElastic',
        endDelay: 700
      }).add({
        scale: [1, 1.5],
        easing: 'easeInElastic',
        opacity: [1, 0]
      });
    } else {
      anime({
        targets: this.chars,
        scale: [0, 1],
        easing: 'easeOutElastic',
        duration: this.options.duration,
        loop: false,

        delay(el, i) {
          return 60 * i;
        }

      });
    }
  }

}

class CharFlip extends Char {
  constructor(instance) {
    super(instance);
    this.setupAnime();
  }

  setupAnime() {
    if (this.options.loop) {
      anime.timeline({
        targets: this.chars,
        loop: true,
        duration: this.options.duration,

        delay(el, i) {
          return 60 * i;
        }

      }).add({
        rotateY: [-90, 0],
        opacity: [0, 1],
        endDelay: 700
      }).add({
        rotateY: [0, 90],
        opacity: [1, 0]
      });
    } else {
      anime({
        targets: this.chars,
        rotateY: [-90, 0],
        opacity: [0, 1],
        duration: this.options.duration,
        loop: false,

        delay(el, i) {
          return 60 * i;
        }

      });
    }
  }

}

class CharZoomIn extends Char {
  constructor(instance) {
    super(instance);
    this.setupAnime();
  }

  setupAnime() {
    if (this.options.loop) {
      anime.timeline({
        targets: this.chars,
        loop: true,
        duration: this.options.duration,

        delay(el, i) {
          return 60 * i;
        }

      }).add({
        scale: [2, 1],
        opacity: [0, 1],
        easing: 'easeOutExpo',
        endDelay: 700
      }).add({
        scale: [1, 0],
        easing: 'easeInExpo',
        opacity: [1, 0]
      });
    } else {
      anime({
        targets: this.chars,
        scale: [2, 1],
        opacity: [0, 1],
        easing: 'easeOutExpo',
        duration: this.options.duration,
        loop: false,

        delay(el, i) {
          return 60 * i;
        }

      });
    }
  }

}

var effects = {
  fade: Fade,
  fadeDown: FadeDown,
  fadeUp: FadeUp,
  fadeLeft: FadeLeft,
  fadeRight: FadeRight,
  zoom: Zoom,
  bounce: Bounce,
  swing: Swing,
  typewrite: Typewrite,
  switchSlider: SwitchSlider,
  switchFade: SwitchFade,
  switchPush: SwitchPush,
  charFade: CharFade,
  charFadeLeft: CharFadeLeft,
  charFadeUp: CharFadeUp,
  charFadeDown: CharFadeDown,
  charPush: CharPush,
  charRotate: CharRotate,
  charBounceOut: CharBounceOut,
  charFlip: CharFlip,
  charZoomIn: CharZoomIn
};

var _dec, _dec2, _dec3, _dec4, _dec5, _class;
var EFFECTS = {};
var AnimateText = (_dec = decorator.styleable(classes), _dec2 = decorator.eventable(events), _dec3 = decorator.stateable(), _dec4 = decorator.optionable(defaults, true), _dec5 = decorator.register(namespace, {
  methods: methods,
  dependencies: dependencies
}), _dec(_class = _dec2(_class = _dec3(_class = _dec4(_class = _dec5(_class = class AnimateText extends Component {
  constructor(element) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(element);
    this.setupOptions(options);
    this.loop = this.options.loop;
    this.mode = this.options.mode;
    this.delay = this.options.delay;
    this.duration = this.options.duration;
    this.setupClasses();
    classes$1.addClass(this.classes.NAMESPACE, this.element);
    this.setupStates();
    this.initialize();
  }

  initialize() {
    if (typeof EFFECTS[this.mode] !== 'undefined') {
      this.effect = new EFFECTS[this.mode](this);
    }

    this.bind();
    this.enter('initialized');
    this.trigger(events.READY);
  }

  splitWord(str) {
    var splitChar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var words = str.split(' ');
    words.forEach((word, index, array) => {
      if (!splitChar) {
        var newWord = document.createElement('span');
        dom.text(word, newWord);
        classes$1.addClass(this.classes.WORD, newWord);
        dom.append(newWord, this.element);
      } else {
        var chars = word.split('');
        chars.forEach(char => {
          var newChar = document.createElement('span');
          dom.text(char, newChar);
          classes$1.addClass(this.classes.CHAR, newChar);
          dom.append(newChar, this.element);
        });
      }

      if (index < array.length - 1) {
        var space = document.createElement('span');
        classes$1.addClass(this.classes.SPACE, space);
        dom.text(' ', space);
        dom.append(space, this.element);
      }
    });
  }

  switchWord() {
    classes$1.addClass(this.classes.SWITCH, this.element);
    var content = document.createElement('span');
    classes$1.addClass(this.classes.WORD, content);
    dom.text(dom.text(this.element), content);
    dom.text('', this.element);
    dom.append(content, this.element);
    this.alt = is.isArray(this.options.alt) ? this.options.alt : [].push(this.options.alt);
    this.alt.forEach(alt => {
      var span = document.createElement('span');
      classes$1.addClass(this.classes.WORD, span);
      dom.text(alt, span);
      dom.append(span, this.element);
    });
  }

  bind() {
    events$1.bindEvent(this.eventName('click touch'), () => false, this.element);
  }

  unbind() {
    events$1.removeEvent(this.eventName(), this.element);
  }

  enable() {
    if (this.is('disabled')) {
      this.leave('disabled');
    }

    this.trigger(events.ENABLE);
  }

  disable() {
    if (!this.is('disabled')) {
      this.enter('disabled');
    }

    this.trigger(events.DISABLE);
  }

  destroy() {
    if (this.is('initialized')) {
      this.unbind();
      this.leave('initialized');
    }

    this.trigger(events.DESTROY);
    super.destroy();
  }

  static registerEffect(name, effect) {
    EFFECTS[name] = effect;
  }

}) || _class) || _class) || _class) || _class) || _class);
Object.keys(effects).forEach(effect => {
  AnimateText.registerEffect(effect, effects[effect]);
});

module.exports = AnimateText;
