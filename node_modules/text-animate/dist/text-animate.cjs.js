'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var charming = _interopDefault(require('charming'));
var clamp = _interopDefault(require('clamp'));
var seedrandom = _interopDefault(require('seedrandom'));

function animationController () {
  const items = [];

  let lastTime = Date.now();


  const add = function (item) {
    items.push(item);
  };


  const remove = function (item) {
    for(let i=0; i < items.length; i++)
      if (items[i] === item)
        return items.splice(i, 1)
  };


  const start = function () {
    requestAnimationFrame(_step);
  };


  const _step = function () {
    const now = Date.now();
    const dt = now - lastTime;
    lastTime = now;
    for (let i=0; i < items.length; i++)
      items[i].step(dt);

    requestAnimationFrame(_step);
  };


  return { add, remove, start }
}

function scaleAlpha (color, amount) {
  return 'rgba(' + color.join(',') + ',' + amount + ')'
}

function animateHeader (el, opts={}) {
  const options = JSON.parse(JSON.stringify(opts));
  el.innerHTML = '<span>' + el.innerText + '</span>';
  const span =  el.querySelector('span');
  span.style.color = 'rgb(' + options.color.join(',') + ')';
  span.style.backgroundColor = '';
  span.style.fontSize = 'inherit';

  let accum = 0;  // milliseconds in the accumulator
  let finished = false;


  // @param int dt time elapsed in milliseconds
  const step = function (dt) {
    accum += dt;
    if (finished || accum < options.delay)
      return

    const actual = accum - options.delay;
    finished = actual >= options.duration;

    span.style.backgroundColor = finished ? '' : scaleAlpha(options.color, 1 - actual/options.duration);
  };


  return { step }
}

function sineOut(t) {
  return Math.sin(t * Math.PI/2)
}

var sineOut_1 = sineOut;

function randomFloat (rng, min, max) {
  return parseFloat( min + rng() * (max - min) )
}

function sineTrough (amount) {
  return 1 - Math.sin(Math.PI * amount)
}


function animateLabel (el, opts={}) {
  const options = JSON.parse(JSON.stringify(opts));
  let spans, characterEffects;
  let effect2Duration = 90;
  let accum = 0;  // ms in the accumulator

  const rng = seedrandom(options.randSeed);

  // initial label glitch
  const effect1Duration = 130;
  const effect1FrameDuration = 30;
  const effect1Frames = [ 1, 0.37, 0.08, 0.98, 0.23 ];


  // @param int dt time elapsed in milliseconds
  const step = function (dt) {
    let finished = (accum >= options.delay + effect1Duration + effect2Duration);

    accum += dt;

    if (accum < options.delay)
      return

    // effect 1 (button glitch effect)
    let actual = accum - options.delay;
    if (actual <= effect1Duration) {
      const currentFrame = Math.floor(actual / effect1FrameDuration);
      const amount = effect1Frames[currentFrame];
      const color = scaleAlpha(options.color, amount);
      for (let i=0; i < spans.length; i++) {
        spans[i].style.backgroundColor = color;
        spans[i].style.color = '';
      }
      return
    }

    actual -= effect1Duration;
    if (actual <= effect2Duration) {
      for (let i=0; i < spans.length; i++) {
        let amount = clamp(actual / characterEffects[i].duration, 0, 1);
        if(characterEffects[i].easing === 1)
          amount = sineOut_1(amount);
        else
          amount = sineTrough(amount);

        amount = clamp(amount, characterEffects[i].min, 1);
        spans[i].style.backgroundColor = scaleAlpha(options.color, amount);
      }
    }

    if (!finished && actual >= effect2Duration) {
      let amount = 1;
      const color = scaleAlpha(options.color, amount);
      for (let i=0; i < spans.length; i++) {
        spans[i].style.backgroundColor = color;
        spans[i].style.color = '';
      }
    }
  };


  const setText = function (text, color) {
    _setup(text);

    if (color)
      options.color = color;

    accum = options.delay;
  };


  const _setup = function (text) {
    const pageBgColor = window.getComputedStyle(document.body, null).getPropertyValue('background-color');

    // add 1 space on each side of the label
    el.innerHTML = '&nbsp;' + text.trim() + '&nbsp;';

    charming(el);

    spans = el.querySelectorAll('span');
    for (let i=0; i < spans.length; i++) {
      spans[i].style.backgroundColor = pageBgColor;
      spans[i].style.color = pageBgColor;
    }

    characterEffects = [];
    for (let i=0; i < spans.length; i++) {
      const effect = {
        min: randomFloat(rng, 0.2, 0.6),
        easing: rng() > 0.5 ? 0 : 1,  // trough vs sineOut
        duration: Math.round(effect2Duration * randomFloat(rng, 0.8, 1.2))
      };
      characterEffects.push(effect);
      effect2Duration = Math.max(effect.duration, effect2Duration);
      if (effect2Duration > 600)
        effect2Duration = 600;
    }
  };


  _setup(el.innerText);

  return { setText, step }
}

// TODO: investigate varying the etchSpeed slightly each frame
function animate1 (el, opts={}) {
  const options = JSON.parse(JSON.stringify(opts));

  let spans;
  let index = 0;  // index of currently etched character
  let accum = 0;  // ms in the accumulator
  const delay = (options.delay ? options.delay : 0);

  const rng = seedrandom(options.randSeed);

  let etchWidth = (rng() > 0.5) ? 1 : 2;

  const _etch = function (i) {
    if (i >= spans.length)
      return

    if (spans[i].innerText === ' ') {
      spans[i].style.backgroundColor = '';
      return
    }
    spans[i].style.color = options.etchFGColor;
    spans[i].style.backgroundColor = options.etchBGColor;
  };


  const _done = function (i) {
    if (i >= spans.length)
      return

    spans[i].style.color = ''; //'initial'
    spans[i].style.backgroundColor = options.targetBGColor;
  };


  const setText = function (text) {
    _setup(text);
    accum = delay;
  };


  const _setup = function (text) {
    charming(el);
    index = 0;
    spans = el.querySelectorAll('span');

    const pageBgColor = window.getComputedStyle(document.body, null).getPropertyValue('background-color');
    for (let i=0; i < spans.length; i++)
      spans[i].style.color = pageBgColor;
  };


  // @param int dt time elapsed in milliseconds
  const step = function (dt) {
    accum += dt;

    if (accum < delay)
      return

    let actual = accum - delay;

    while (actual >= options.etchSpeed) {
      _done(index);
      if (etchWidth > 1)
        _done(index + 1);
      index += etchWidth;

      if (index >= spans.length)
        return

      etchWidth = (rng() > 0.5) ? 1 : 2;
      _etch(index);  // set current index to etching
      if (etchWidth > 1)
        _etch(index+1);

      actual -= options.etchSpeed;
      accum -= options.etchSpeed;
    }
  };

  _setup(el.innerText);

  return { setText, step }
}

// split the contents of a span by newlines, putting each
// line into a new span. ignores empty spans
function spanifyByNewlines (el) {
  const lines = el.innerHTML.split('\n');
  let newContent = '';

  for (let i=0; i < lines.length; i++) {
    // don't include spans that have a new line
    if (lines[i].trim().length === 0)
      continue

    newContent += ('<span>' + lines[i] + '</span><br>');
  }
  el.innerHTML = newContent;
}

// given an inline element, split by newlines and render each line at once
function animateTextLines (el, opts={}) {
  const options = JSON.parse(JSON.stringify(opts));
  let spans = [];
  let accum = 0;
  let total = 0;
  let index = 0;  // index of currently etched line


  function etch (i) {
    if (i >= spans.length)
      return

    if (spans[i].innerText === ' ')
      return spans[i].style.backgroundColor = ''

    spans[i].style.color = options.etchFGColor;
    spans[i].style.backgroundColor = options.etchBGColor;
  }


  function done (i) {
    if (i >= spans.length)
      return

    spans[i].style.color = options.targetFGColor;
    spans[i].style.backgroundColor = options.targetBGColor;

    if (options.targetFontWeight)
      spans[i].style.fontWeight = options.targetFontWeight;

    if (options.targetFontStyle)
      spans[i].style.fontStyle = options.targetFontStyle;
  }


  const setText = function (text) {
    _setup(text);
    total = accum = 0;
    index = 0;
  };


  // @param int dt time elapsed in milliseconds
  const step = function (dt) {
    if (index >= spans.length)
      return

    total += dt;
    if (total < options.delay)
      return

    accum += dt;


    while(accum >= options.etchSpeed) {
      done(index);
      index++;

      if (index >= spans.length)
        return

      etch(index);
      accum -= options.etchSpeed;
    }
  };


  const _setup = function (text) {
    const pageBgColor = window.getComputedStyle(document.body, null).getPropertyValue('background-color');

    el.innerHTML = text.trim();
    spanifyByNewlines(el);
    spans = el.querySelectorAll('span');

    for (let i=0; i < spans.length; i++)
      spans[i].style.color = pageBgColor;
  };


  _setup(el.innerText);

  return { setText, step }
}

function splitByTimings (text, timings) {
  const words = [];

  let lastStart = 0;

  timings.forEach(function (timing, idx) {
    // ignore the first entry
    if (idx === 0)
      return

    words.push(text.substring(lastStart, timing.start));
    lastStart = timing.start;
  });

  words.push(text.substring(lastStart));
  return words
}


// given a mapping of text and it's times, draw the output
// @param options.timings
//   e.g., The described word ("Hello") begins 243 milliseconds after the audio stream begins, and starts at byte 0 and ends at byte 6 of the input text.
//   [ { "time":243, "type":"word", "start":0, "end":5, "value":"Hello" },
//     { "time":519, "type":"word", "start":6, "end":15, "value":"miker1728" } ]
function animateTextTimedWords (el, options={}) {
  const { audio, text, color, timings } = options;

  const src = audio.src;

  let allDone = false;

  // convert ms to seconds
  const endTime = (timings[timings.length-1].time + 400) / 1000;

  const spans = [];


  // @param int dt time elapsed in milliseconds
  const step = function (dt) {

    if (allDone)
      return

    // if the audio src changed, the audio is no longer playing. assume the animation is done
    // this can happen in scenarios where the audio element is shared among multiple animated
    // elements.
    if (src != audio.src)
      _markAllVisible();

    // audio duration, currentTime are expressed in seconds
    const currentTime = Math.round(audio.currentTime * 1000); // convert seconds to ms

    for (let i=0; i < spans.length; i++) {
      const startTime = timings[i].time;

      if (currentTime < startTime)
        return

      const duration = (i < timings.length-1) ? (timings[i+1].time - timings[i].time) : 400;
      const endTime = startTime + duration;

      let progress = (currentTime - startTime) / (endTime - startTime);
      progress = clamp(progress, 0, 1);

      spans[i].style.color = '';
      spans[i].style.backgroundColor = scaleAlpha(options.color, 1 - progress);

      if (i === spans.length-1 && progress > 0.99)
        _markAllVisible();
    }
  };

  const _markAllVisible = function () {
    allDone = true;
    for (let i=0; i < spans.length; i++) {
      spans[i].style.color = '';
      spans[i].style.backgroundColor = '';
    }
  };


  const _setup = function (text) {
    el.innerHTML = '';

    const words = splitByTimings(text, timings);

    const pageBgColor = window.getComputedStyle(document.body, null).getPropertyValue('background-color');

    for (let i=0; i < words.length; i++) {
      if (words[i].trim().length === 0)
        continue

      const span = document.createElement('span');
      span.innerText = words[i];
      span.style.color = pageBgColor;
      spans.push(span);
      el.appendChild(span);
    }
  };

  _setup(text);

  return { step }
}

function animateWords (el, opts={}) {
  const options = JSON.parse(JSON.stringify(opts));

  const spans = [];
  let accum = 0;  // ms in the accumulator


  const appendText = function (text) {
    const words = text.trim().split(' ');
    const pageBgColor = window.getComputedStyle(document.body, null).getPropertyValue('background-color');

    for (let i=0; i < words.length; i++) {
      let span = document.createElement('span');
      span.innerText = words[i] + ' ';
      spans.push(span);
      el.appendChild(span);
    }
  };


  // @param int dt time elapsed in milliseconds
  const step = function (dt) {
    accum += dt;

    const amount = 1 - (accum / options.duration);
    for (let i=0; i < spans.length; i++)
      spans[i].style.backgroundColor = scaleAlpha(options.color, amount);
  };


  const _setup = function () {
    const pageBgColor = window.getComputedStyle(document.body, null).getPropertyValue('background-color');
    accum = 0;
    el.innerHTML = '';
  };


  _setup();

  return { appendText, step }
}

var index = {
  controller: animationController, header: animateHeader, label: animateLabel, text: animate1, textLine: animateTextLines, timed: animateTextTimedWords, words: animateWords
};

module.exports = index;
